# 第五章：陣列和指標

<!--

#### 第五章：陣列和指標

- 陣列和陣列操作
- 指標和指標操作
- 指標和陣列的關係
- 動態記憶體分配

-->

陣列和指標是相當重要且常用的概念，也是許多人學習上的難點。理解陣列和指標的概念，將有助於你更好地掌握 C++ 語言的基礎，從而更有效地開發軟體和解決問題。在本篇教學中，我將詳細介紹陣列和指標的概念、如何聲明和使用它們，以及陣列和指標在 C++ 中的實際應用。我希望這篇教學能為你提供實用的指導，讓你更加熟悉 C++ 語言並且更加自信地應用它。

## 陣列是啥

在 C++ 中，陣列（Array）是一種具有相同資料型別的元素集合，這些元素可以透過索引或下標（Index）來訪問。陣列的資料型別可以是基本型別（例如 int、float、char 等），也可以是自定義型別（例如結構體、類等）。陣列可以在程式中宣告(declare)並初始化(initialize)，也可以在運行時動態(dynamic)地創建和修改。

陣列的索引是從 0 開始的，也就是說，如果一個陣列的大小是 N，那麼它的索引範圍是從 0 到 N-1。例如，一個大小為 5 的 int 陣列可以表示為：`a[0]`、`a[1]`、`a[2]`、`a[3]`、`a[4]`。我們可以使用索引來訪問和修改陣列中的元素，例如：`a[0] = 1;`。

我們實際來個範例

```cpp
int arr[5] = {1, 2, 3, 4, 5}; // 創建一個內容型別為 int 的陣列
```

就如同上面提到的，想要提取出陣列的索引位值，可以用 `arr[index]` 這個語法來表示像是

```cpp
std::cout << arr[0] << std::endl;
```

這樣就可以輸出 arr 這個陣列的第一個(索引 0)值，除此之外，我們也可以將它結合回全，就可以把陣列裡面的所有值給印出來

```cpp
for (int i=0; i<5; i++) {
  std::cout << arr[i] << std::endl;
}
```

我們馬上來個範例

```cpp
#include <iostream>

int main() {
  int arr[5] = {1, 2, 3, 4, 5};
  for (int i = 0; i<5; i++) {
    std::cout << arr[i] << std::endl;
  }
  return 0;
}
```

這個範例的輸出會是

```
1
2
3
4
5
```
除了在宣告時賦值外，也可以在宣告後重新賦值

```cpp
int numbers[5] = {0};
numbers[0] = 123;
for (int i = 0; i<5; i++) {
    std::cout << numbers[i] << std::endl;
}
```

輸出會是

```
123
0
0
0
0
```

## 指標

許多初學者在學習指標時常常會遇到很大的困難，但是只要知道指標最根本的定義就不會一直搞不懂了，那究竟甚麼是指標呢？

指標(Pointer)簡單來說就是一個存放記憶體位置的變數，超簡單的對吧，我們馬上來看看怎麼用

```cpp
#include <iostream>

int main(){
  int var = 10;
  void* ptr = &var;

  std::cout << ptr << std::endl;
}
```

這一個範例程式中，我先宣告了一個整數變數 `var`，接著再宣告一個指標，而這個指標變數存的就是 `var` 這個變數在記憶體中的位置，從這個範例中我們可以看到 C++ 中的指標變數都會加一個`*` 心號來表示，而`void` 則是指標的型別，void 是指說型別不確定，當然，在這個範例中我們可以確定型別是整數(int)，所以也可以改寫成 `int* ptr = &var`。接著我們看到 & 符號(ampersand)，他代表該變數位址，他可以取出 var 這個變數在記憶體上的位置，接著存到指標裡面(還記得前面說的指標就是存位址的變數吧)。

所以上面範例程式的輸出會是 var 的位址

```
0x7ffc994b57dc
```

應該會是長類似這樣的東西，每次執行的結果都會不一樣。

那我們能夠取出特定位址的值嗎，當然可以只需要使用取址運算子，怎麼做呢

```cpp
std::cout << *ptr << std::endl;
```

就是這麼簡單，他將會輸出 var 的值。

```
10
```

要注意，如果要使用這個方式找到位址裡的內容，就必須定義好指標的型別不能只用 `void`，否則會報錯，如在這個範例中，ptr 應該有的型別是 `int*`。

除了取出來當然也可以改裡面的值

```cpp
*ptr = 20;
```

然而這個動作與下面的這個動作是完全一樣的

```cpp
var = 20;
```

所以我們可以知道 `ptr` 這個變數存著 `var` 的位址，而利用 `*ptr` 可以取出 ptr 指向位址中的值，也就是 `var`，這樣理解了對吧。


## 陣列與指標 (Array & Pointer)

接著我們回到最初的起點，看看陣列的使用

```cpp
int arr[5] = {0};
```

我們用這種方法宣告陣列，接著我們試試看把 `arr` 給輸出

```cpp
std::cout << arr << endl;
```
你會獲得一個很類似剛剛講指標所提到的為址，大概長這樣

```
0x7fff444e6f90
```

但這其實並不是很像指標為址，他就是指標，可能有點無法理解，不過其實我們在宣告一個陣列的時候只是告訴程式需要開一個那樣大小的空間給我們，而她事實上就是起始位址，所以剛剛的程式碼輸出才會是一個位址，也就是 `arr` 陣列的起始位址。

還記得我們剛剛怎麼取出陣列中特定索引的值嗎？可能是這樣做

```cpp
std::cout << arr[2] << std::endl;
```
但是還記得我們前一小節有提到可以使用取址符(*)來取得指標的值，接著又想到，陣列的變數是陣列的起始位址，所以我們可以這麼做

```cpp
std::cout << *(arr + 2) << std::endl;
```
利用將位址往後推來達到索引的效果，接著取址內容，就可以獲得該位置的內容，所以不難發現 `*(arr + 2)` 和 `arr[2]` 是一樣的東西。

## 字串

字串，簡單來說就是一串字元，那「一串」是甚麼概念呢?簡單來說就是`字元陣列`，特別的是他以空字符 `\0` 結尾，我們馬上來看看如何宣告一個字串

```cpp
char str[5]; 
str[0] = 'L';
str[1] = 'a';
str[2] = 'z';
str[3] = 'p';
str[4] = '\0';
```
這樣就是創建一個字串了

```cpp
#include <iostream>

int main() {
  char str1[5]; 
  str1[0] = 'L';
  str1[1] = 'a';
  str1[2] = 'z';
  str1[3] = 'p';
  str1[4] = '\0';

  std::cout << str1 << std::endl;
}
```

以上為創建、輸出一個字串的範例。正確的輸出為

```
Lazp
```
但其實可以省略陣列大小，讓編譯器自己判斷，變這樣

```cpp
char str[] = "Lazp";
```

這樣也成功宣告一個函數了(同時省略了空字符，但是陣列長度仍是 5)。還記得上面講到的可以使用指標的方式來宣告陣列嗎，既然字串是陣列自然也可以這麼做

```cpp
char *str3  = "Lazp";
```

# 字串處理

字串我們可以有非常多的操作，也有許多內建的標準函數，首先我們來看看 `<cstring>`(string.h) 這個函式庫，第一個功能是 `strlen`，在這之前我們必須再程式的最上頭加上 macro 來引入函數庫

```cpp
#include <cstring>
```

接著我們在主函式(main())中宣告一個字串

```cpp
int main() {
  char *str = "Lazp";

  return 0;
}
```

接著就可以使用 strlen 函數來找到字串的長度

```cpp
std::cout << strlen(str) << std::endl;
```

可以發現他是不會計算 `\0` 的，這個函數非常的簡單，其實可以自己實作，如下

```cpp
size_t strlen(const char* str){
  size_t result = 0;
  while(str[result] != '\0') {
    result++;
  }
  return result;
}
```
> Tips: `size_t` 其實跟 `unsigned long` 是一樣的東西

如果已經掌握前面所有的知識點，基本上可以無痛理解這段程式碼，如果沒辦法理解，那就該好好複習囉！

接著我們來介紹下一個，`strcmp`，他可以比較兩個字串是否相同
```cpp
char *first_str = "lazp";
char *second_str = "lazp";
std::cout << strcmp(first_str, second_str) << std::endl;
```

那他會有甚麼輸出呢？他會有三種輸出：

- 0: 輸出的值如果是 0 代表他們兩個相等，也就是所有字元都相等
- 大於 0: 當`first_str`中第一個不匹配的字符的 ASCII 值大於`second_str`中相應的字符的ASCII值時，將返回大於零的值(即他們的 ASCII 差)。
- 小於 0: 當 `first_str` 中的第一個不匹配字符的 ASCII 值小於 `second_str` 中相應字符的 ASCII 值時，將返回一個小於零的值。

當然也可以自己實作

```cpp
int strcmp(const char *f, const char *s) {
  int i=0;
  while (i <= strlen(f)) {
    if (f[i] != s[i]) {
      return (f[i] - s[i]);
    }
    i++;
  }
  return 0;
}
```

## 結語

今天介紹了很多跟陣列有關的知識，以後將會遇到更多都可以再學。